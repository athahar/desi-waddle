# Deck Shuffling & Management System Architecture

> **Origin**: This architecture is adapted from the WaitLetsPlay app's sophisticated deck management system, which is considered one of the best implementations for card-based mobile games. Desi Waddle implements this system in `src/core/deckManager.ts` and `src/utils/deckBuilder.ts`.

## Table of Contents
1. [Overview](#overview)
2. [Core Problem Statement](#core-problem-statement)
3. [Solution Architecture](#solution-architecture)
4. [Core Algorithms](#core-algorithms)
5. [Key Features](#key-features)
6. [Implementation Details](#implementation-details)
7. [Desi Waddle Integration](#desi-waddle-integration)
8. [Data Flow](#data-flow)
9. [Storage Strategy](#storage-strategy)
10. [Edge Cases & Error Handling](#edge-cases--error-handling)
11. [Testing & Debugging](#testing--debugging)
12. [Future Enhancements](#future-enhancements)

---

## Overview

The deck shuffling system is designed to solve a critical UX problem in card-based games: **preventing repetitive card appearances while ensuring fresh content across play sessions**.

The system uses a combination of:
- **Seeded pseudorandom number generation** for deterministic shuffling
- **30-day cooldown tracking** to prevent recent cards from reappearing
- **Progressive reveal** to work through the deck systematically
- **50% refresh rule** to balance freshness with variety
- **Session continuity** to maintain progress across app restarts

This architecture ensures players experience a balanced mix of familiar and fresh content without seeing the same cards too frequently.

---

## Core Problem Statement

### The Challenge
Traditional random card selection has several UX issues:

1. **True randomness feels repetitive** - Users may see the same card multiple times in a short period
2. **No memory across sessions** - Cards can repeat immediately after restarting the app
3. **Unpredictable variety** - Some cards appear frequently, others rarely
4. **Poor progression feeling** - Users don't feel they're "working through" content

### User Impact
Without proper deck management:
- Users complain about seeing "the same cards over and over"
- Engagement drops as content feels stale
- Large card databases feel underutilized
- No sense of progress or mastery

---

## Solution Architecture

### Core Philosophy: Progressive Reveal with Controlled Freshness

The system works like a **smart deck of physical cards**:

1. **Shuffle once** with a seeded algorithm (not on every draw)
2. **Work through progressively** - deal cards in order from shuffled deck
3. **Track what's been seen** - remember cards shown in last 30 days
4. **Refresh strategically** - only reshuffle when 50%+ of deck is consumed
5. **Maintain continuity** - preserve progress across app restarts

### Key Principles

| Principle | Implementation | User Benefit |
|-----------|---------------|--------------|
| **Deterministic Shuffle** | Seeded PRNG (Mulberry32) | Consistent experience within session |
| **Cooldown Protection** | 30-day AsyncStorage tracking | No recent repeats across sessions |
| **Progressive Consumption** | Work through shuffled array | Feels like "making progress" |
| **Refresh Threshold** | 50% rule before reshuffling | Balance between variety and freshness |
| **Session Persistence** | AsyncStorage state management | Seamless app restart experience |

---

## Core Algorithms

### 1. Mulberry32 PRNG (Seeded Pseudorandom Number Generator)

**Purpose**: Generate deterministic random numbers from a seed value

**Source**: `src/utils/deckBuilder.ts:15-24`

```typescript
function mulberry32(seed: number): () => number {
  return function() {
    let t = (seed += 0x6D2B79F5);
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  };
}
```

**Why Mulberry32?**
- Fast (single multiplication and XOR operations)
- Good statistical properties for card shuffling
- Deterministic (same seed = same sequence)
- Small footprint (9 lines of code)

**Seed Generation**:
```typescript
// From desi-charades/src/core/deckManager.ts:178
const seed = `${Math.random()}_${Date.now()}`;
```

Combines random value + timestamp to ensure unique sessions.

### 2. Fisher-Yates Shuffle with Seeding

**Purpose**: Shuffle array uniformly using seeded random function

**Source**: `src/utils/deckBuilder.ts:31-40`

```typescript
export function shuffleSeeded<T>(arr: T[], rand: () => number): T[] {
  const result = [...arr];
  for (let i = result.length - 1; i > 0; i--) {
    const j = Math.floor(rand() * (i + 1));
    [result[i], result[j]] = [result[j], result[i]];
  }
  return result;
}
```

**Why Fisher-Yates?**
- Proven uniform distribution (every permutation equally likely)
- O(n) time complexity (efficient for large decks)
- In-place shuffling (minimal memory overhead)
- Works with any random number generator

**Key Difference from `Math.random()`:**
```typescript
// ‚ùå Non-deterministic (different results each call)
const shuffled = shuffleArray([1,2,3,4,5]); // Uses Math.random()

// ‚úÖ Deterministic (same seed = same shuffle)
const rand = mulberry32(12345);
const shuffled = shuffleSeeded([1,2,3,4,5], rand); // Repeatable
```

### 3. Seeded Randomization Benefits

**Session Stability Example**:

```typescript
// Session A (seed: 42)
const rand1 = mulberry32(42);
const deck1 = shuffleSeeded([1,2,3,4,5], rand1);
// Result: [3, 1, 5, 2, 4]

// Session B (same seed: 42)
const rand2 = mulberry32(42);
const deck2 = shuffleSeeded([1,2,3,4,5], rand2);
// Result: [3, 1, 5, 2, 4] ‚Üê IDENTICAL!
```

**Real-World Impact**:
- User starts game, sees cards A, B, C
- App crashes or user exits
- User restarts ‚Üí continues from card D (not reshuffling)

---

## Key Features

### Feature 1: 30-Day Cooldown Per Card

**Implementation**: `src/utils/deckBuilder.ts:259-284`

```typescript
const DAYS_30 = 30 * 24 * 60 * 60 * 1000; // 30 days in milliseconds

async function isItemInCooldown(gameKey: string, itemId: string | number): Promise<boolean> {
  const historyKey = `${gameKey}_card_history`;
  const history = await AsyncStorage.getItem(historyKey);

  if (!history) return false;

  const cardHistory = JSON.parse(history);
  const lastSeen = cardHistory[itemId];

  if (!lastSeen) return false;

  const timeSinceLastSeen = Date.now() - lastSeen;
  return timeSinceLastSeen < DAYS_30;
}
```

**Storage Format**:
```json
{
  "@deck_builder:charades_bollywood-universe_card_history": {
    "card_001": 1728912000000,
    "card_002": 1728998400000,
    "card_003": 1729084800000
  }
}
```

**User Experience**:
- Play on Monday, see "Dilwale Dulhania Le Jayenge"
- Play on Tuesday (next day) ‚Üí won't see same card
- Play 31 days later ‚Üí card is eligible again

### Feature 2: 50% Refresh Rule

**Implementation**: `src/utils/deckBuilder.ts:170-207`

```typescript
export async function refreshDeckIfNeeded<T extends { id: string | number }>(
  gameKey: string,
  allItems: T[]
): Promise<T[]> {
  const historyKey = `${gameKey}_card_history`;
  const history = await AsyncStorage.getItem(historyKey);

  if (!history) {
    // First time playing - return all cards
    return allItems;
  }

  const cardHistory = JSON.parse(history);
  const now = Date.now();

  // Filter out cards in cooldown (seen in last 30 days)
  const availableItems = allItems.filter((item) => {
    const lastSeen = cardHistory[item.id];
    if (!lastSeen) return true; // Never seen
    return now - lastSeen >= DAYS_30; // Cooldown expired
  });

  // Calculate percentage of deck still available
  const percentageAvailable = availableItems.length / allItems.length;

  // Refresh threshold: 50%
  if (percentageAvailable < 0.5) {
    if (__DEV__) {
      console.log(`üîÑ Deck refresh triggered: ${availableItems.length}/${allItems.length} available (${(percentageAvailable * 100).toFixed(1)}%)`);
    }

    // Clear history to make all cards available again
    await AsyncStorage.removeItem(historyKey);
    return allItems;
  }

  return availableItems;
}
```

**Behavior Scenarios**:

| Cards Seen | Available | % Available | Action | Reasoning |
|------------|-----------|-------------|--------|-----------|
| 10 / 100 | 90 | 90% | Continue | Plenty of fresh content |
| 30 / 100 | 70 | 70% | Continue | Still good variety |
| 49 / 100 | 51 | 51% | Continue | Just above threshold |
| 50 / 100 | 50 | 50% | Continue | Exactly at threshold |
| 51 / 100 | 49 | 49% | **Refresh** | Below 50% - reset history |
| 80 / 100 | 20 | 20% | **Refresh** | Running out of fresh cards |

**Why 50%?**
- Too low (30%) ‚Üí premature refreshes, less variety
- Too high (70%) ‚Üí users see same cards too often
- 50% ‚Üí optimal balance between freshness and variety

### Feature 3: Progressive Reveal

**Implementation**: `src/core/deckManager.ts:231-292`

```typescript
export async function getNextCards(
  gameId: string,
  packId: string,
  categoryId: string | undefined,
  allCards: DeckItem[],
  count: number = 1
): Promise<DeckItem[]> {
  // 1. Load or create session
  let session = await loadSession(gameId);
  if (!session) {
    const sessionId = await startNewSession(gameId, packId, categoryId, allCards.length);
    session = await loadSession(gameId);
  }

  // 2. Get available cards (implements 50% rule + 30-day cooldown)
  const availableCards = await refreshDeckIfNeeded(gameId, allCards);

  // 3. Get seeded random function for this session
  const rand = await getSessionRand(gameId);

  // 4. Shuffle with session seed (deterministic within session)
  const shuffled = shuffleSeeded(availableCards, rand);

  // 5. Take next cards from shuffled deck
  const selected = shuffled.slice(0, Math.min(count, shuffled.length));

  // 6. Mark cards as shown (for 30-day tracking)
  for (const card of selected) {
    await markItemSeen(gameId, card.id);
    session.cardsShown.push(card.id);
  }

  await saveSession(session);
  return selected;
}
```

**Progressive Flow**:

```
Session Start (seed: abc123)
‚îú‚îÄ Shuffle all cards: [5, 12, 3, 8, 1, 9, ...]
‚îú‚îÄ Draw 1: Card 5 ‚Üí mark seen
‚îú‚îÄ Draw 2: Card 12 ‚Üí mark seen
‚îú‚îÄ Draw 3: Card 3 ‚Üí mark seen
‚îú‚îÄ ...
‚îú‚îÄ Draw 50: Card 7 ‚Üí mark seen (50% consumed)
‚îî‚îÄ Next draw: Refresh check ‚Üí clear history ‚Üí new shuffle
```

**vs. True Random**:

```
True Random (no memory)
‚îú‚îÄ Draw 1: Random card (maybe 5)
‚îú‚îÄ Draw 2: Random card (maybe 5 again!) ‚Üê BAD UX
‚îú‚îÄ Draw 3: Random card (maybe 12)
‚îú‚îÄ Draw 4: Random card (maybe 5 again!) ‚Üê BAD UX
```

### Feature 4: Session Continuity

**Implementation**: `src/core/deckManager.ts:78-105`

```typescript
async function loadSession(gameId: string): Promise<SessionState | null> {
  try {
    const key = SESSION_KEY(gameId);
    const data = await AsyncStorage.getItem(key);
    if (!data) return null;

    const session: SessionState = JSON.parse(data);

    // Check if session should be refreshed (30-day cooldown)
    const createdAt = new Date(session.createdAt);
    const now = new Date();
    const daysSinceCreated = Math.floor((now.getTime() - createdAt.getTime()) / (1000 * 60 * 60 * 24));

    if (daysSinceCreated >= COOLDOWN_DAYS) {
      if (__DEV__) {
        console.log(`Session ${session.sessionId} expired (${daysSinceCreated} days old)`);
      }
      return null; // Will trigger new session
    }

    return session;
  } catch (error) {
    if (__DEV__) {
      console.error(`Error loading session for ${gameId}:`, error);
    }
    return null;
  }
}
```

**Session State Structure**:

```typescript
interface SessionState {
  sessionId: string;                    // "session_1728912000000_abc123"
  gameId: string;                       // "charades_bollywood-universe_90s-movies"
  packId: string;                       // "bollywood-universe"
  categoryId?: string;                  // "90s-movies"
  seed: string;                         // "0.123456_1728912000000"
  createdAt: string;                    // "2025-10-15T10:30:00.000Z"
  cardsShown: string[];                 // ["card_001", "card_002", ...]
  totalCardsInPack: number;             // 100
  events: SessionEvent[];               // [{ type: 'CARD_SHOWN', ... }, ...]
}
```

**User Journey Example**:

```
Day 1, 10:00 AM
‚îú‚îÄ User opens app
‚îú‚îÄ Start session (seed: xyz789)
‚îú‚îÄ Shuffle deck: [12, 5, 18, 3, ...]
‚îú‚îÄ Show cards: 12, 5, 18
‚îî‚îÄ Save session state

Day 1, 10:05 AM (app crashes)
‚îú‚îÄ User reopens app
‚îú‚îÄ Load session (seed: xyz789)
‚îú‚îÄ Deck still: [12, 5, 18, 3, ...]
‚îú‚îÄ Already shown: [12, 5, 18]
‚îî‚îÄ Continue from card 3 ‚Üê SEAMLESS!

Day 1, 2:00 PM (user closes app)
‚îî‚îÄ Session persisted in AsyncStorage

Day 2, 9:00 AM (user reopens)
‚îú‚îÄ Load session (created 23 hours ago)
‚îú‚îÄ Session still valid (< 30 days old)
‚îî‚îÄ Continue from where they left off

Day 32 (31 days later)
‚îú‚îÄ Load session (created 31 days ago)
‚îú‚îÄ Session expired (‚â• 30 days old)
‚îî‚îÄ Start fresh session with new shuffle
```

### Feature 5: First Card Protection

**Implementation**: `src/utils/deckBuilder.ts:97-137` (buildDeck function)

```typescript
export async function buildDeck<T extends Item>(options: BuildDeckOptions<T>): Promise<T[]> {
  const { gameKey, allItems, ageBands, categories, difficulties } = options;

  // 1. Filter items by criteria
  let filteredItems = filterItems(allItems, { ageBands, categories, difficulties });

  // 2. Get available items (after cooldown check)
  const availableItems = await refreshDeckIfNeeded(gameKey, filteredItems);

  // 3. Get seeded shuffle
  const rand = await getSessionRand(gameKey);
  let shuffledItems = shuffleSeeded(availableItems, rand);

  // 4. First card protection
  const lastFirstCard = await getLastFirstCard(gameKey);
  if (lastFirstCard && shuffledItems.length > 1) {
    // If first card matches last session's first card, swap with second card
    if (shuffledItems[0].id === lastFirstCard) {
      [shuffledItems[0], shuffledItems[1]] = [shuffledItems[1], shuffledItems[0]];

      if (__DEV__) {
        console.log(`üîÑ First card protection: Swapped ${lastFirstCard} to avoid repeat`);
      }
    }
  }

  // 5. Save this session's first card for next time
  if (shuffledItems.length > 0) {
    await saveFirstCard(gameKey, shuffledItems[0].id);
  }

  return shuffledItems;
}

async function getLastFirstCard(gameKey: string): Promise<string | null> {
  const key = `${gameKey}_first_card`;
  return await AsyncStorage.getItem(key);
}

async function saveFirstCard(gameKey: string, cardId: string | number): Promise<void> {
  const key = `${gameKey}_first_card`;
  await AsyncStorage.setItem(key, String(cardId));
}
```

**Why This Matters**:

The first card has **disproportionate psychological impact**:
- It's the first thing users see when starting a game
- Creates immediate impression of variety (or lack thereof)
- If same card opens two sessions ‚Üí feels broken to users

**Example Without Protection**:

```
Monday Session
‚îú‚îÄ Shuffle (seed: 111): [42, 18, 5, 12, ...]
‚îî‚îÄ First card: 42 ("Dilwale Dulhania Le Jayenge")

Monday Session Ends
‚îî‚îÄ User closes app

Tuesday Session (30 days haven't passed yet, so card 42 still in cooldown)
‚îú‚îÄ Available cards: [1,2,3...41,43,44...100] (all except 42)
‚îú‚îÄ Shuffle (seed: 222): [18, 5, 12, 89, ...]
‚îî‚îÄ First card: 18 ‚Üê DIFFERENT ‚úì

Alternative Bad Scenario (without first card protection)
Tuesday Session
‚îú‚îÄ Shuffle (seed: 333): [42, 91, 7, ...]
‚îî‚îÄ First card: 42 ‚Üê SAME AS YESTERDAY ‚úó
```

**With First Card Protection**:

```typescript
// Tuesday session shuffle produces: [42, 91, 7, ...]
// System detects: firstCard (42) === lastFirstCard (42)
// System swaps: [42, 91, ...] ‚Üí [91, 42, ...]
// User sees: 91 ‚Üê DIFFERENT!
```

---

## Implementation Details

### Code Organization

```
src/
‚îú‚îÄ‚îÄ core/
‚îÇ   ‚îî‚îÄ‚îÄ deckManager.ts          # High-level deck management
‚îÇ       ‚îú‚îÄ‚îÄ startNewSession()
‚îÇ       ‚îú‚îÄ‚îÄ getNextCards()
‚îÇ       ‚îú‚îÄ‚îÄ endSession()
‚îÇ       ‚îî‚îÄ‚îÄ getCurrentSessionStats()
‚îÇ
‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îî‚îÄ‚îÄ deckBuilder.ts          # Core shuffling algorithms
‚îÇ       ‚îú‚îÄ‚îÄ mulberry32()
‚îÇ       ‚îú‚îÄ‚îÄ shuffleSeeded()
‚îÇ       ‚îú‚îÄ‚îÄ refreshDeckIfNeeded()
‚îÇ       ‚îú‚îÄ‚îÄ markItemSeen()
‚îÇ       ‚îî‚îÄ‚îÄ buildDeck()
‚îÇ
‚îî‚îÄ‚îÄ devlog/
    ‚îî‚îÄ‚îÄ deck.ts                 # Dev console logging wrapper
```

### Key Functions Reference

#### `startNewSession(gameId, packId, categoryId, totalCards)`
**Purpose**: Initialize new play session with unique seed and tracking

**Returns**: `sessionId` string

**Side Effects**:
- Generates unique session ID
- Creates seeded shuffle
- Saves session state to AsyncStorage
- Logs SESSION_START event

**Usage**:
```typescript
const sessionId = await startNewSession(
  'charades_bollywood-universe_90s-movies',
  'bollywood-universe',
  '90s-movies',
  100
);
```

#### `getNextCards(gameId, packId, categoryId, allCards, count)`
**Purpose**: Get next card(s) from shuffled deck with cooldown protection

**Returns**: `DeckItem[]` array

**Side Effects**:
- Checks 50% refresh threshold
- Applies 30-day cooldown filter
- Marks returned cards as seen
- Updates session state
- Logs CARD_SHOWN events

**Usage**:
```typescript
const nextCards = await getNextCards(
  'charades_bollywood-universe_90s-movies',
  'bollywood-universe',
  '90s-movies',
  allBollywoodCards,
  1  // Get 1 card
);
```

#### `refreshDeckIfNeeded(gameKey, allItems)`
**Purpose**: Check if deck should refresh based on 50% rule

**Returns**: `T[]` - Available items (filtered by cooldown)

**Side Effects**:
- If <50% available ‚Üí clears card history
- Logs refresh event in dev mode

**Usage**:
```typescript
const availableCards = await refreshDeckIfNeeded(
  'charades_bollywood-universe_90s-movies',
  allCards
);
```

#### `markItemSeen(gameKey, itemId)`
**Purpose**: Record card as seen with timestamp for 30-day tracking

**Side Effects**:
- Updates card history in AsyncStorage
- Stores current timestamp

**Usage**:
```typescript
await markItemSeen('charades_bollywood-universe_90s-movies', 'card_042');
```

#### `getCurrentSessionStats(gameId)`
**Purpose**: Get current session statistics for dev console

**Returns**:
```typescript
{
  sessionId: string;
  seed: string;
  cardsShown: number;
  totalCards: number;
  percentageUsed: number;
  daysSinceCreated: number;
  daysUntilRefresh: number;
}
```

**Usage**:
```typescript
const stats = await getCurrentSessionStats('charades_bollywood-universe_90s-movies');
console.log(`Session ${stats.sessionId}: ${stats.percentageUsed}% consumed`);
```

---

## Desi Waddle Integration

### Game ID Format

The `gameId` uniquely identifies a deck within the app:

```typescript
// Format: {gameType}_{packId}_{categoryId}
const gameId = `charades_${packId}_${categoryId}`;

// Examples:
"charades_bollywood-universe_90s-movies"
"charades_street-food_mumbai-specials"
"charades_cricket-fever_ipl-madness"
"guess-movie_bollywood-universe_all"
```

### Integration Points

#### 1. CharadesScreen.tsx

```typescript
// src/screens/CharadesScreen.tsx
export default function CharadesScreen({ route }: Props) {
  const { packId, categoryId } = route.params;

  // Build game ID
  const gameId = `charades_${packId}_${categoryId}`;

  // Load cards for this category
  const allCards = getCardsByPackAndCategory(packId, categoryId);

  // Get next card using deck manager
  useEffect(() => {
    const loadCard = async () => {
      const [nextCard] = await getNextCards(
        gameId,
        packId,
        categoryId,
        allCards,
        1
      );
      setCurrentCard(nextCard);
    };
    loadCard();
  }, [packId, categoryId]);

  // End session when game finishes
  useEffect(() => {
    return () => {
      endSession(gameId);
    };
  }, [gameId]);
}
```

#### 2. GuessMoviePlayScreen.tsx

```typescript
// src/screens/GuessMoviePlayScreen.tsx
export default function GuessMoviePlayScreen({ route }: Props) {
  const { packId } = route.params;

  // Guess Movie uses pack-level deck (no category)
  const gameId = `guess-movie_${packId}_all`;

  // Load all dialogues for this pack
  const allDialogues = getDialoguesByPack(packId);

  // Get next 10 cards for round
  useEffect(() => {
    const loadRound = async () => {
      const roundCards = await getNextCards(
        gameId,
        packId,
        undefined,  // No category for Guess Movie
        allDialogues,
        10  // Get 10 cards for round
      );
      setRoundData(roundCards);
    };
    loadRound();
  }, [packId]);
}
```

### Storage Keys Used

Desi Waddle creates the following AsyncStorage keys:

```typescript
// Session state (per game)
"@deck_manager:session:charades_bollywood-universe_90s-movies"
"@deck_manager:session:charades_street-food_mumbai-specials"
"@deck_manager:session:guess-movie_bollywood-universe_all"

// Card history (per game, for 30-day tracking)
"charades_bollywood-universe_90s-movies_card_history"
"guess-movie_bollywood-universe_all_card_history"

// Session seeds (per game, for deterministic shuffle)
"charades_bollywood-universe_90s-movies_seed"
"guess-movie_bollywood-universe_all_seed"

// First card tracking (per game, for first card protection)
"charades_bollywood-universe_90s-movies_first_card"

// Global history (for dev console)
"@deck_manager:history"
```

### Dev Console Integration

Triple-tap anywhere in the app to open Dev Console:

```typescript
// src/devlog/DevPanel.tsx
import { getCurrentSessionStats, getDevHistory, exportHistoryCsv } from '../core/deckManager';

// View current session
const stats = await getCurrentSessionStats('charades_bollywood-universe_90s-movies');
console.log(`
  Session: ${stats.sessionId}
  Seed: ${stats.seed}
  Progress: ${stats.cardsShown}/${stats.totalCards} (${stats.percentageUsed.toFixed(1)}%)
  Age: ${stats.daysSinceCreated} days
  Refresh in: ${stats.daysUntilRefresh} days
`);

// Export history as CSV
const csv = await exportHistoryCsv();
// Share via Sharing API
```

---

## Data Flow

### Complete Card Selection Flow

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 1. User starts game (CharadesScreen or GuessMoviePlayScreen)   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                             ‚îÇ
                             ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 2. Build gameId: "charades_{packId}_{categoryId}"              ‚îÇ
‚îÇ    Example: "charades_bollywood-universe_90s-movies"           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                             ‚îÇ
                             ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 3. Load all cards for pack/category                            ‚îÇ
‚îÇ    const allCards = getCardsByPackAndCategory(packId, catId)   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                             ‚îÇ
                             ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 4. Call getNextCards(gameId, packId, categoryId, allCards, 1)  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                             ‚îÇ
                             ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 5. Load or create session                                       ‚îÇ
‚îÇ    ‚îú‚îÄ Check AsyncStorage for existing session                  ‚îÇ
‚îÇ    ‚îú‚îÄ If found: Load sessionId, seed, cardsShown               ‚îÇ
‚îÇ    ‚îî‚îÄ If not: startNewSession() ‚Üí generate seed                ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                             ‚îÇ
                             ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 6. refreshDeckIfNeeded(gameId, allCards)                       ‚îÇ
‚îÇ    ‚îú‚îÄ Load card history from AsyncStorage                      ‚îÇ
‚îÇ    ‚îú‚îÄ Filter out cards in 30-day cooldown                      ‚îÇ
‚îÇ    ‚îú‚îÄ Calculate % available                                     ‚îÇ
‚îÇ    ‚îú‚îÄ If <50%: Clear history, return all cards                 ‚îÇ
‚îÇ    ‚îî‚îÄ If ‚â•50%: Return available cards only                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                             ‚îÇ
                             ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 7. Get seeded random function                                   ‚îÇ
‚îÇ    const rand = await getSessionRand(gameId)                   ‚îÇ
‚îÇ    ‚îî‚îÄ Loads seed from AsyncStorage                             ‚îÇ
‚îÇ    ‚îî‚îÄ Returns mulberry32(seed) function                        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                             ‚îÇ
                             ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 8. Shuffle cards with seed                                      ‚îÇ
‚îÇ    const shuffled = shuffleSeeded(availableCards, rand)        ‚îÇ
‚îÇ    ‚îî‚îÄ Fisher-Yates shuffle with deterministic random           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                             ‚îÇ
                             ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 9. Take next card(s) from shuffled deck                        ‚îÇ
‚îÇ    const selected = shuffled.slice(0, count)                   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                             ‚îÇ
                             ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 10. Mark cards as seen                                          ‚îÇ
‚îÇ     for (const card of selected) {                             ‚îÇ
‚îÇ       await markItemSeen(gameId, card.id)                      ‚îÇ
‚îÇ       session.cardsShown.push(card.id)                         ‚îÇ
‚îÇ     }                                                           ‚îÇ
‚îÇ     ‚îî‚îÄ Stores timestamp in card_history                        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                             ‚îÇ
                             ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 11. Save session state                                          ‚îÇ
‚îÇ     await saveSession(session)                                 ‚îÇ
‚îÇ     ‚îî‚îÄ Persist sessionId, seed, cardsShown, events             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                             ‚îÇ
                             ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 12. Return selected card(s) to UI                              ‚îÇ
‚îÇ     return selected                                             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                             ‚îÇ
                             ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 13. Display card in game screen                                ‚îÇ
‚îÇ     setCurrentCard(nextCard)                                   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### State Transitions

```
[Session Lifecycle]

Start Game
    ‚îÇ
    ‚ñº
No Session Exists ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ                           ‚îÇ
    ‚ñº                           ‚ñº
Create Session          Session Exists
    ‚îÇ                           ‚îÇ
    ‚îÇ                           ‚ñº
    ‚îÇ                   Check Expiry
    ‚îÇ                           ‚îÇ
    ‚îÇ                   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ                   ‚îÇ                ‚îÇ
    ‚îÇ           Expired (‚â•30 days)   Valid (<30 days)
    ‚îÇ                   ‚îÇ                ‚îÇ
    ‚îÇ                   ‚ñº                ‚îÇ
    ‚îÇ           Create New Session       ‚îÇ
    ‚îÇ                   ‚îÇ                ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                        ‚îÇ
                        ‚ñº
                Load Available Cards
                        ‚îÇ
                        ‚ñº
            ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
            ‚îÇ                        ‚îÇ
    <50% Available          ‚â•50% Available
            ‚îÇ                        ‚îÇ
            ‚ñº                        ‚îÇ
    Refresh Deck                     ‚îÇ
    (Clear History)                  ‚îÇ
            ‚îÇ                        ‚îÇ
            ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                         ‚îÇ
                         ‚ñº
                  Shuffle with Seed
                         ‚îÇ
                         ‚ñº
                  Return Next Card
                         ‚îÇ
                         ‚ñº
                   Mark as Seen
                         ‚îÇ
                         ‚ñº
                   Save Session
                         ‚îÇ
                         ‚ñº
                   Display Card
```

---

## Storage Strategy

### AsyncStorage Schema

#### 1. Session State
**Key**: `@deck_manager:session:{gameId}`

```json
{
  "sessionId": "session_1728912000000_abc123",
  "gameId": "charades_bollywood-universe_90s-movies",
  "packId": "bollywood-universe",
  "categoryId": "90s-movies",
  "seed": "0.123456_1728912000000",
  "createdAt": "2025-10-15T10:30:00.000Z",
  "cardsShown": [
    "card_042",
    "card_018",
    "card_091"
  ],
  "totalCardsInPack": 100,
  "events": [
    {
      "type": "SESSION_START",
      "timestamp": "2025-10-15T10:30:00.000Z",
      "metadata": {
        "packId": "bollywood-universe",
        "categoryId": "90s-movies",
        "totalCards": 100
      }
    },
    {
      "type": "CARD_SHOWN",
      "timestamp": "2025-10-15T10:30:15.123Z",
      "cardId": "card_042",
      "metadata": {
        "term": "Dilwale Dulhania Le Jayenge",
        "category": "90s-movies"
      }
    }
  ]
}
```

#### 2. Card History (30-day tracking)
**Key**: `{gameId}_card_history`

```json
{
  "card_001": 1728825600000,
  "card_002": 1728912000000,
  "card_042": 1728998400000,
  "card_018": 1729084800000,
  "card_091": 1729171200000
}
```

**Note**: Timestamp is Unix epoch milliseconds (`Date.now()`)

#### 3. Session Seed
**Key**: `{gameId}_seed`

```json
"0.123456_1728912000000"
```

#### 4. First Card Protection
**Key**: `{gameId}_first_card`

```json
"card_042"
```

#### 5. Global History (Dev Console)
**Key**: `@deck_manager:history`

```json
{
  "sessions": [
    {
      "sessionId": "session_1728912000000_abc123",
      "gameId": "charades_bollywood-universe_90s-movies",
      "packId": "bollywood-universe",
      "categoryId": "90s-movies",
      "seed": "0.123456_1728912000000",
      "createdAt": "2025-10-15T10:30:00.000Z",
      "cardsShown": ["card_042", "card_018"],
      "totalCardsInPack": 100,
      "events": [...]
    }
  ],
  "totalPlays": 15,
  "totalCardsShown": 347
}
```

**Note**: Limited to last 50 sessions to prevent storage bloat

### Storage Operations Performance

| Operation | Complexity | Storage Size | Notes |
|-----------|-----------|--------------|-------|
| Load Session | O(1) | ~1-2 KB | Single AsyncStorage read |
| Save Session | O(1) | ~1-2 KB | Single AsyncStorage write |
| Load Card History | O(1) | ~5-10 KB | Single AsyncStorage read, JSON parse |
| Mark Card Seen | O(n) | ~5-10 KB | Read history, update, write back (n = cards seen) |
| Refresh Check | O(n) | - | Filter array (n = total cards) |
| Export CSV | O(m) | ~20-50 KB | Iterate sessions (m = history count) |

### Storage Limits & Cleanup

**AsyncStorage Limits (iOS)**:
- Practical limit: ~6 MB (varies by device)
- Desi Waddle usage: ~50-100 KB total

**Cleanup Strategy**:
```typescript
// Limit events per session
const MAX_EVENTS_PER_SESSION = 200;

// Limit history sessions
const MAX_HISTORY_SESSIONS = 50;

// Auto-cleanup on session save
if (session.events.length > MAX_EVENTS_PER_SESSION) {
  session.events = session.events.slice(-MAX_EVENTS_PER_SESSION);
}
```

---

## Edge Cases & Error Handling

### 1. Empty Deck (All Cards in Cooldown)

**Scenario**: User has played through 100% of category within 30 days

**Detection**:
```typescript
const availableCards = await refreshDeckIfNeeded(gameId, allCards);
if (availableCards.length === 0) {
  // All cards in cooldown!
}
```

**Solution**:
```typescript
// refreshDeckIfNeeded automatically handles this
if (percentageAvailable < 0.5) {  // <50% available
  await AsyncStorage.removeItem(historyKey);
  return allItems;  // Reset and return all cards
}
```

**User Experience**: Seamless - system automatically refreshes when <50% available, preventing "empty deck" scenario

### 2. Small Deck (< 10 Cards)

**Scenario**: Category has only 5-10 cards

**Challenge**: 50% rule means refresh after 2-5 cards ‚Üí feels too frequent

**Current Behavior**:
```typescript
// Category with 10 cards
// After showing 5 cards: 5 available (50%) ‚Üí no refresh
// After showing 6 cards: 4 available (40%) ‚Üí refresh
```

**Potential Improvement** (not yet implemented):
```typescript
// Adaptive threshold for small decks
const REFRESH_THRESHOLD = allCards.length < 20 ? 0.3 : 0.5;
// Small decks refresh at 30% instead of 50%
```

### 3. Clock Changes (User Travels or Adjusts Time)

**Scenario**: User travels to different timezone or manually changes device clock

**Impact on Cooldowns**:
```typescript
// Card seen on Monday 10:00 AM (timestamp: 1728912000000)
// User changes clock back 1 week
// System thinks: timeSinceLastSeen = -604800000 (negative!)
// Card in cooldown? timeSinceLastSeen < DAYS_30 ‚Üí true ‚úì
```

**System Behavior**: Clock changes backward don't break cooldowns (still protected). Clock changes forward may make cards available early (acceptable).

### 4. Corrupted AsyncStorage Data

**Scenario**: App crash during save, manual data manipulation, or migration issues

**Detection & Handling**:
```typescript
async function loadSession(gameId: string): Promise<SessionState | null> {
  try {
    const data = await AsyncStorage.getItem(key);
    if (!data) return null;

    const session: SessionState = JSON.parse(data);

    // Validate structure
    if (!session.sessionId || !session.seed) {
      throw new Error('Invalid session structure');
    }

    return session;
  } catch (error) {
    if (__DEV__) {
      console.error(`Error loading session for ${gameId}:`, error);
    }
    return null;  // Graceful degradation: create new session
  }
}
```

**Fallback Strategy**:
1. Try to load data
2. If corrupted ‚Üí return null
3. System creates new session automatically
4. User experience: seamless (may see some repeated cards)

### 5. App Update (Schema Changes)

**Scenario**: Update changes session structure (e.g., add new field)

**Migration Strategy**:
```typescript
// Example migration for new field
async function migrateSession(session: any): Promise<SessionState> {
  // Add default values for missing fields
  return {
    ...session,
    newField: session.newField ?? defaultValue,
  };
}
```

**Best Practice**: Use optional fields (`?`) in TypeScript for backwards compatibility

### 6. Multiple Games Running Simultaneously

**Scenario**: User switches between Charades and Guess Movie mid-game

**Isolation**:
```typescript
// Each game has unique gameId
const charadesId = "charades_bollywood-universe_90s-movies";
const guessMovieId = "guess-movie_bollywood-universe_all";

// Completely independent sessions
await getNextCards(charadesId, ...);  // No impact on
await getNextCards(guessMovieId, ...); // this session
```

**Storage**: Separate keys ensure no cross-contamination

---

## Testing & Debugging

### Dev Console Features

**Access**: Triple-tap anywhere in app (development builds only)

**Available Commands**:

#### 1. View Current Session Stats
```typescript
import { getCurrentSessionStats } from '../core/deckManager';

const stats = await getCurrentSessionStats('charades_bollywood-universe_90s-movies');
console.log(`
  Session: ${stats.sessionId}
  Seed: ${stats.seed}
  Cards Shown: ${stats.cardsShown}/${stats.totalCards}
  % Used: ${stats.percentageUsed.toFixed(1)}%
  Age: ${stats.daysSinceCreated} days old
  Refreshes in: ${stats.daysUntilRefresh} days
`);
```

#### 2. View Session Events
```typescript
import { getSessionEvents } from '../core/deckManager';

const events = await getSessionEvents('charades_bollywood-universe_90s-movies');
events.forEach(event => {
  console.log(`[${event.timestamp}] ${event.type}`, event.metadata);
});
```

#### 3. Export History as CSV
```typescript
import { exportHistoryCsv } from '../core/deckManager';
import * as Sharing from 'expo-sharing';

const csv = await exportHistoryCsv();
const fileUri = `${FileSystem.documentDirectory}deck_history.csv`;
await FileSystem.writeAsStringAsync(fileUri, csv);
await Sharing.shareAsync(fileUri);
```

**CSV Format**:
```csv
Session ID,Game ID,Pack ID,Category ID,Created At,Cards Shown,Total Cards,% Used,Events Count
session_1728912000000_abc123,charades_bollywood-universe_90s-movies,bollywood-universe,90s-movies,2025-10-15T10:30:00.000Z,42,100,42.0%,85
```

#### 4. Reset Current Session
```typescript
import { resetSession } from '../core/deckManager';

await resetSession('charades_bollywood-universe_90s-movies');
// Clears session state, next game will start fresh
```

#### 5. Clear All Data (Nuclear Option)
```typescript
import { clearAllData } from '../core/deckManager';

await clearAllData();
// Clears ALL sessions, history, and card tracking
// Use with caution!
```

### Manual Testing Checklist

#### Basic Functionality
- [ ] Start new game ‚Üí verify cards appear
- [ ] Play through 5 cards ‚Üí verify no repeats within session
- [ ] Close and reopen app ‚Üí verify session continues from where it left off
- [ ] Play through 50%+ of deck ‚Üí verify refresh occurs

#### Cooldown Testing
- [ ] Play 10 cards from category A
- [ ] Immediately play category A again ‚Üí verify no repeats of those 10 cards
- [ ] Wait 31 days (or manually adjust timestamps) ‚Üí verify cards reappear

#### Edge Cases
- [ ] Play category with only 5 cards ‚Üí verify deck refreshes appropriately
- [ ] Switch between Charades and Guess Movie mid-game ‚Üí verify no cross-contamination
- [ ] Force app crash during gameplay ‚Üí verify session recovery on restart
- [ ] Play through 100% of small category ‚Üí verify automatic refresh

#### First Card Protection
- [ ] Note first card of session 1
- [ ] Complete session 1
- [ ] Start session 2 ‚Üí verify different first card (if possible given cooldowns)

#### Dev Console
- [ ] Triple-tap to open dev console
- [ ] View session stats ‚Üí verify accuracy
- [ ] Export CSV ‚Üí verify data correctness
- [ ] Reset session ‚Üí verify fresh start

### Automated Testing (Future)

```typescript
// Example unit test for refreshDeckIfNeeded
describe('refreshDeckIfNeeded', () => {
  it('should return all cards when <50% available', async () => {
    const gameKey = 'test_game';
    const allCards = createMockCards(100);

    // Mark 51 cards as seen (49% available)
    for (let i = 0; i < 51; i++) {
      await markItemSeen(gameKey, allCards[i].id);
    }

    const result = await refreshDeckIfNeeded(gameKey, allCards);

    // Should refresh and return all 100 cards
    expect(result.length).toBe(100);
  });

  it('should filter cooldown cards when ‚â•50% available', async () => {
    const gameKey = 'test_game_2';
    const allCards = createMockCards(100);

    // Mark 30 cards as seen (70% available)
    for (let i = 0; i < 30; i++) {
      await markItemSeen(gameKey, allCards[i].id);
    }

    const result = await refreshDeckIfNeeded(gameKey, allCards);

    // Should return only 70 available cards
    expect(result.length).toBe(70);
  });
});
```

---

## Future Enhancements

### 1. Adaptive Seasonal Mix

**Current**: Static 50% refresh threshold for all categories

**Enhancement**: Dynamic threshold based on category size and user engagement

```typescript
// Adaptive threshold calculation
function getRefreshThreshold(categorySize: number, playFrequency: number): number {
  if (categorySize < 20) return 0.3;  // Small decks: refresh at 30%
  if (categorySize > 100) return 0.6; // Large decks: refresh at 60%
  if (playFrequency > 5) return 0.4;  // Frequent players: refresh earlier
  return 0.5;  // Default
}
```

**Benefits**:
- Small categories feel less repetitive
- Large categories have more variety before refresh
- Frequent players get fresher content

### 2. Per-User Progress Tracking

**Current**: Single session per gameId (works for solo play)

**Enhancement**: Multi-user profiles with separate progress

```typescript
interface UserSession extends SessionState {
  userId: string;  // "player_1", "player_2", etc.
}

// Separate deck state per user
const gameKey = `${gameId}_${userId}`;
```

**Use Case**: Family with multiple users on same device

### 3. Difficulty-Aware Refresh

**Current**: All cards treated equally in shuffle

**Enhancement**: Progressive difficulty reveal (easier cards first)

```typescript
// Already implemented in WaitLetsPlay's buildCountryDeck
export async function buildCountryDeck<T extends Item & { difficulty: Difficulty }>(
  options: BuildDeckOptions<T>
): Promise<T[]> {
  // 1. Filter items
  let filteredItems = filterItems(allItems, filters);

  // 2. Group by difficulty
  const easy = filteredItems.filter(item => item.difficulty === 'easy');
  const medium = filteredItems.filter(item => item.difficulty === 'medium');
  const hard = filteredItems.filter(item => item.difficulty === 'hard');

  // 3. Shuffle each group separately
  const rand = await getSessionRand(gameKey);
  const shuffledEasy = shuffleSeeded(easy, rand);
  const shuffledMedium = shuffleSeeded(medium, rand);
  const shuffledHard = shuffleSeeded(hard, rand);

  // 4. Interleave: E, M, E, H, M, E, H, M, ...
  return interleave([shuffledEasy, shuffledMedium, shuffledHard]);
}
```

**Benefits**:
- Better onboarding for new players
- Gradual difficulty ramp
- More engaging progression

### 4. Streak & Achievement Tracking

**Enhancement**: Track user milestones with deck system

```typescript
interface Achievements {
  cardsSeenTotal: number;
  categoriesCompleted: string[];
  longestStreak: number;
  perfectRounds: number;
}

// Trigger on session events
if (session.cardsShown.length === session.totalCardsInPack) {
  unlockAchievement('category_master', categoryId);
}
```

**User Motivation**: Gamification encourages exploration of all content

### 5. Smart Cooldown Adjustment

**Current**: Fixed 30-day cooldown for all cards

**Enhancement**: Variable cooldown based on card popularity

```typescript
interface CardMetrics {
  timesShown: number;
  timesSkipped: number;
  avgRating?: number;
}

// Popular cards get longer cooldown
function getCooldownDays(cardId: string, metrics: CardMetrics): number {
  const skipRate = metrics.timesSkipped / metrics.timesShown;
  if (skipRate > 0.5) return 15;  // Unpopular ‚Üí shorter cooldown
  if (skipRate < 0.1) return 45;  // Very popular ‚Üí longer cooldown
  return 30;  // Default
}
```

**Benefits**:
- Unpopular cards reappear sooner (more chances)
- Popular cards get longer breaks (reduce fatigue)

### 6. Cross-Category Recommendations

**Enhancement**: Suggest categories based on completion and engagement

```typescript
interface CategoryRecommendation {
  categoryId: string;
  score: number;
  reason: 'similar_to_completed' | 'high_rating' | 'new_content';
}

// Example: User completed "90s Movies" ‚Üí recommend "Iconic Dialogues"
async function getRecommendations(userId: string): Promise<CategoryRecommendation[]> {
  const history = await getUserHistory(userId);
  // ML or rules-based recommendation logic
  return recommendations;
}
```

### 7. Offline-First Sync

**Current**: AsyncStorage (local only)

**Enhancement**: Cloud sync for multi-device progress

```typescript
interface CloudSyncState {
  lastSyncAt: string;
  deviceId: string;
  sessions: SessionState[];
}

// Sync on app start/background
async function syncWithCloud() {
  const local = await loadLocalSessions();
  const remote = await fetchRemoteSessions();
  const merged = mergeSessionsByTimestamp(local, remote);
  await saveLocalSessions(merged);
  await uploadSessions(merged);
}
```

**User Benefit**: Seamless experience across iPhone and iPad

---

## Performance Considerations

### Optimization Strategies

#### 1. Lazy Loading for Large Decks
```typescript
// Don't load all cards upfront
const allCards = useMemo(() => {
  return getCardsByPackAndCategory(packId, categoryId);
}, [packId, categoryId]);
```

#### 2. Memoized Shuffle Results
```typescript
// Cache shuffled deck for session
const shuffledDeck = useMemo(() => {
  const rand = getSessionRandSync(gameId);
  return shuffleSeeded(allCards, rand);
}, [gameId, allCards]);
```

#### 3. Debounced Storage Writes
```typescript
// Batch session updates
const debouncedSave = useCallback(
  debounce((session: SessionState) => {
    saveSession(session);
  }, 1000),
  []
);
```

#### 4. Index-Based Card History
```typescript
// Instead of array of IDs, use Set for O(1) lookup
const cardHistory = new Set(session.cardsShown);
const isCardSeen = cardHistory.has(cardId);  // O(1)
```

### Performance Benchmarks

| Operation | Current Time | Target | Status |
|-----------|--------------|--------|--------|
| Load Session | <10ms | <50ms | ‚úÖ |
| Shuffle 100 cards | <5ms | <20ms | ‚úÖ |
| Mark card seen | <15ms | <50ms | ‚úÖ |
| Check cooldown | <10ms | <30ms | ‚úÖ |
| Export CSV | <100ms | <500ms | ‚úÖ |
| Full deck refresh | <50ms | <100ms | ‚úÖ |

**Tested on**: iPhone 12 (iOS 17.5)

---

## Summary

The deck shuffling system is a sophisticated solution to a common UX problem in card-based games. By combining:

1. **Seeded PRNG** - Deterministic shuffling for session stability
2. **30-day cooldown** - Prevents recent cards from reappearing
3. **Progressive reveal** - Work through deck systematically
4. **50% refresh rule** - Strategic reshuffling for variety
5. **Session continuity** - Seamless progress across app restarts
6. **First card protection** - Avoids repetitive opening cards

The system delivers a balanced experience that feels both fresh and fair to users.

**Key Takeaway**: True randomness ‚â† Good UX. Controlled randomness with memory creates better user experiences.

---

**Document Version**: 1.0
**Last Updated**: 2025-10-15
**Maintained By**: Desi Waddle Development Team
**Original Architecture**: WaitLetsPlay (documented and adapted)

**Related Documentation**:
- [Project Plan](../specs/project-plan.md)
- [Implementation Plan](../specs/implementation-plan.md)
- [Guess the Movie Spec](../specs/guess-the-movie.md)

**Source Code**:
- `src/core/deckManager.ts` - High-level deck management
- `src/utils/deckBuilder.ts` - Core shuffling algorithms
- `src/devlog/deck.ts` - Dev console integration
